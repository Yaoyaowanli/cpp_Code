//
// Created by 姚远 on 2022/10/24.
//

#include "inheritance.h"


void test_inheritance1(){
    /*student s1;
    teacher t1;

    s1.print();
    t1.print();*/

/*
    //基类对象和派生类对象的赋值转换
    //我们知道student类继承了person类，student类拥有person类的所有成员，那么他们之间可以相互赋值转换码？
    //  1、派生类对象可以赋值基类对象/指针/引用
    student s1;
    s1.set("我是s1",111);
    person p1;
    p1.set("我是p1",999);
    s1.print();
    p1.print();
    p1 = s1;
    person* ptr = &s1;
    person& ref = s1;
    //赋值
    p1.print();
    // 我们发现派生类对象可以赋值给基类对象，但是会丢弃掉派生类中基类没有的数据，只会赋值基类定义过的字段。
    //  2、基类对象不能赋值给派生类对象
    //  3、基类的指针可以通过强制类型转换赋值给派生类指针
*/
}

void test_inheritance2(){
    //我们实现了3个类，person2类是一个基类，里面自己定义了默认成员函数
    //student2是一个public继承person2的子类，里面自己定义了默认成员函数
    //teacher2也是一个public继承person2的子类，没有写任何函数。

    //首先我们观察一下编译器自动生成的默认的构造函数会做啥呢
    teacher2 t1;
    teacher2 t2(t1);
    t2 = t1;
    //我们发现编译器生成的构造函数在初始化teacher时先调用了person2的构造函数对基类先完成了初始化
    //拷贝构造和operator= 同样
    //析构时，则先完成了teacher2的析构，又自动调用了person2的析构函数完成了基类的析构
}

void test_inheritance3(){
    assistant a1;
    //a1._name = "peter";
    //a1.student3::_name = "peter";
    //a1.teacher3::_name = "jack";
    a1._name = "peter";
}



void test_inheritance4(){
    //对象在内存中是如何存储的？
    //我们有A4B4C4D4 4个class 其中B4C4继承了A4，D4继承了B4C4，可以得到D4是一个菱形继承。
    //我们给出一个D4的实例，他有多大呢？
    D4 d1;
    cout << sizeof(d1) << endl;
    //D4里有4个字节，同时继承下来的B4、C4又各自又4字节，这是12字节，而B4、C4又各自继承了A4，他们又各自增加了4字节
    //那么就是5个4字节=20字节

    d1.B4::_a =1;
    d1.C4::_a =2;
    d1._b = 3;
    d1._c = 4;
    d1._d = 5;
    //我们发现在内存中是这样存储的：
    //          D4
    //  D4::B4  B4::A4   _b
    //  D4::C4  C4::A4   _c
    //                   _d
    //
    //                      D4
    // D4::B4::_a     D4::B4::_b     D4::C4::_a     D4::C4::_c      D4::_d
    // 01 00 00 00    03 00 00 00    02 00 00 00    04 00 00 00    05 00 00 00

    //接下来看看加了虚拟继承之后是什么样子
    D5 d2;
    cout << sizeof(d2) << endl;
    //我们发现d2变为40 字节了
    d2.B5::_a =1;
    d2.C5::_a =2;
    d2._b = 3;
    d2._c = 4;
    d2._d = 5;
    d2._a = 6;
    //内存
    // D5::B5::A5::_a                   D5::B5::_b                    D5::C5::A5::_a                    D5::C5::_c
    //  c0 31 60 01     01 00 00 00     03 00 00 00     01 00 00 00     d8 31 60 01     01 00 00 00     04 00 00 00
    // D5::B5::A5::_a这个值是地址记录了到D5::_a的偏移量                    D5::C5::A5::_a 同样记录了偏移量
    //  D5::_d          D5::_a
    //  05 00 00 00     06 00 00 00     01 00 00 00
    //
    //  我们发现用了虚拟继承之后内存会变大，是因为要解决二义性和数据冗余，保留了虚基类存在的同时又在子类中添加了一个公共的基类数据空间
    //  虚基类中存了一个指针，指向虚基表，表中记录了他的地址到公共基类数据空间的偏移量，当需要操作数据时就会加上该偏移量，就是基类的数据地址
}